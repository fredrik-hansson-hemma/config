/* 
 * recursively get the group information 
 * The used dataset is being used to store what's already checked to keep from infinite loop
 * 
 */
%macro Recursion(firsttime=0, used=work.used);
	%if &firsttime eq 1 %then %do;
		/* prepare for the recursive call */
		proc sql noprint;
			create table &used. (name char(200));
		quit;

		proc datasets lib=adExt nolist;
			delete ldapgrps;
		run;
		quit;
		%let name1      = &GROUP_FILTER.;
		%let name_len = 1;
		%if %symexist(GROUP_FILTER2) %then %do;
			%let name2      = &GROUP_FILTER2.;
			%let name_len = 2;
			%if %symexist(GROUP_FILTER3) %then %do;
				%let name3      = &GROUP_FILTER3.;
				%let name_len = 3;
				%if %symexist(GROUP_FILTER4) %then %do;
					%let name4      = &GROUP_FILTER4.;
					%let name_len = 4;
					%if %symexist(GROUP_FILTER5) %then %do;
						%let name5      = &GROUP_FILTER5.;
						%let name_len = 5;
					%end;
				%end;
			%end;
		%end;
	%end;
	%else %do;
		/* store the name into macro variables */
		data _null_;
			set adExt.ldapgrps end=last;
			name = scan(scan(member, 1, ","), 2, "=");
			call symput("name" || trim(left(_n_)), trim(left(name)));
			if last then call symput("name_len", trim(left(_n_)));
		run;
	%end;
	%let rerun = 0;
	%do i=1 %to &name_len;
		/* test whether this is already done */
		proc sql noprint;
		   select count(*) into :done from &used. where name="&&name&i";
		quit;

		%if &done=0 %then %do;
			%let rerun = 1;
			%let n     = %bquote(&&name&i);  /* escape if names contain quotes */
			proc sql noprint;
				insert into &used. values("&n");
			quit;
			%put Checking membership for &n ;
			%ADGroupFilter(filter=&n);
		%end;
	%end;
	%if &rerun eq 1 %then %do;
		%Recursion;
	%end;
%mend;


%macro vanligaADGrupper();
 
	%let igen = 1;

  %do %while (&igen = 1);

		
	  data medlemsgrupper;
			set adExt.ldapgrps;

			/* Hämta alla medlemmar som är grupper. Om medlemsnamn innehåller siffror är det antagligen ett användarID */
	  	/* och sållas därför bort. */
			if (
				index(member,'1') or index(member,'2') or index(member,'3') or index(member,'4') or index(member,'5') or
				index(member,'6') or index(member,'7') or index(member,'8') or index(member,'9') or index(member,'0')
				) then delete;
			if missing(member) then delete; 
			name = member;
		run;
 
		proc sort data= medlemsgrupper nodupkey;
			by name;
		run;

		proc sort data=adext.ldapgrps out=ldapgrps nodupkey;
			by name;
		run;

		/* Filterar bort de medlemmar som finns i ldaggrps som huvudgrupper. */
		data nyagrupper;
			merge 
				medlemsgrupper (in=medlemsgrupper)
				ldapgrps (in=ldapgrps);
			by name;
			if medlemsgrupper and not ldapgrps then output;
			else delete;
		run;	

		%let dsid = %sysfunc(open(nyagrupper));
		%let antal = %sysfunc(attrn(&dsid, NOBS)); 
		/* Loopen ska avslutas om det inte finns mer medlemsgrupper att hämta in. */ 
		%if &antal < 1 %then %let igen = 0;
	  
		%do %while (%sysfunc(fetch(&dsid)) = 0);
			%let name = %sysfunc(getvarc(&dsid, %sysfunc(varnum(&dsid, NAME)))); 
			%ADGroupFilter(filter=&name); 
		%end; /* end: do while fetch(dsid) */
		%let dsid = %sysfunc(close(&dsid));
  
	%end; /* end: do until igen = 1 */

%mend;

%Recursion(firsttime=1);

/* Start: Anpassning LUL. */
/* I AD:s SAS-grupper kan IT-samordnare lägga in vanliga AD-grupper (typ -Users -Users-FIM). */
/* För varje AD-grupp som inte har ändelsen -SAS görs ny sökning mot AD för att hämta upp medlemmar. */

%vanligaADGrupper;

/* Slut: Anpassning LUL. */
