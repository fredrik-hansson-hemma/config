/******************************************************************************************/
/* If the dataset is empty, then something went wrong with the extract.  Cancel execution */
/* with the SYSINFO macro variable set to 3.                                              */
/******************************************************************************************/

proc sql noprint;
   select count(*) into :ldapgrps_nobs from adExt.ldapgrps;
quit;

data _null_;
   if &ldapgrps_nobs eq 0 then do;
      put "ERROR: Group extraction failed. The dataset adExt.ldapgrps contains no observations.";
      put "ERROR: Cancelling execution of submitted statements.";
      put "ERROR: Verify these values are correct: ADServer, ADPort, ADGrpBaseDN, keyidvar, displayName";
      put "ERROR: Try re-run the code with this line commented";
      put "ERROR:     filter=""(&(cn=&GROUP_FILTER.)(objectCategory=group)(objectClass=group))"" ;; ";
      abort cancel 3;
   end;
run;

* Kontrollerar att fimObjects innehåller rader.;
proc sql noprint;
   select count(*) into :fimobjects_nobs from &dwlib..fimobjects;
quit;

data _null_;
   if &fimobjects_nobs eq 0 then do;
      put "ERROR: The dataset &dwlib..fimobjects contains no observations.";
      put "ERROR: Cancelling execution of submitted statements.";
      abort cancel 3;
   end;
run;
* Slut: Kontrollerar att fimObjects innehåller rader.;

/**********************************************************************/
/* Sort the list of groups extracted from Active Directory by the     */
/* distinguishedName attribute which represents the actual Group      */
/* name. This is necessary so the following  datastep can do BY       */
/* processing on the Group list in order to detect the next unique    */
/* Group name and output it to &idgrptbl.                             */
/**********************************************************************/

proc sql;
  drop index distinguishedName from adExt.ldapgrps;
quit;

proc sort data=adExt.ldapgrps;
     by distinguishedName;
run;  
 
proc datasets library=adExt memtype=data nowarn nolist;    /* Create Index */
     modify ldapgrps;                         /* for speedy retrieval */
     index create distinguishedName;
run;                                                                                         
 
/******************************************************************************/
/* The following datastep creates the normalized tables for groups and group  */
/* membership from the adExt.ldapusers extracted above.             */
/******************************************************************************/

* Start: Anpassning LUL;
* Skapar format med alla superanvändare;
data superanv;
  set adext.ldapgrps (where=(upcase(name) = "LUL-SYSTEM-SAS-SUPERANVÄNDARE"));
	start = member;
	end = member;
	label= "J";
	type = "C";
	fmtname="superanv";
run;

/* Ta bort detta när gruppen Superanvändare börjar fyllas på */
/* dummy */
data superanv;
	start="XXX000"; end="XXX000"; label="J"; type="C"; fmtname="superanv";
	output;
run;
/* Slut: Ta bort detta när gruppen Superanvändare börjar fyllas på */

proc format lib=work.formats cntlin= superanv;
run;



* Slut: Anpassning LUL;

data &idgrptbla &idgrpmemstbla;
     %defineidgrpcols;        /* Macros to define Table Columns from %mduimpc */
     %defineidgrpmemscols; 

     set adExt.ldapgrps;
     by distinguishedName;     

		 * Start: Anpassning LUL.;
     * Gruppnamnen i AD slutar på -SAS, vi tar bort -SAS ur namnet innan vi laddar till metadata.; 
		 	if upcase(substr(compress(reverse(name)), 1, 4)) = 'SAS-' then do;
					org_group = 1; * flagga för att gruppen är en organisationsgrupp;
				  tmp_name = substr(compress(reverse(name)), 5);
					name = compress(reverse(tmp_name));
					drop tmp_name;
			end;
		
			* Slut: Anpassning LUL.;

     /*************************************************************************/
     /* When distinguishedName value changes set its column values and output */
     /* the next unique Group name to the Table of Groups: &idgrptbl.         */
     /*************************************************************************/
     if first.distinguishedName then do;
        keyid = distinguishedName;
     
        /* description already assigned from original */
        grptype="" ;
        output &idgrptbl;
		

     end;

     /****************************************************************************/
     /* Each row in adExt.ldapgrps represents membership in a Group so */
     /* set its column values and output unconditionally to &idgrpmemstbl.       */
     /****************************************************************************/

     grpkeyid=distinguishedName;	 
     memkeyid=member;
     * memkeyid=saMAccountName;

     output &idgrpmemstbl;

		 * Start: Anpassning LUL;
		 * Om det är en organisationsgrupp skapas det en admingrupp för den. Admingruppen har prefix -W (Write). Medlemmar är superanvändare;

		 if org_group = 1 and first.distinguishedName then do;
		 	  name = compress(name !!"-W");
				distinguishedName = name;
        keyid = name;
     
        /* description already assigned from original */
        grptype="" ;
        output &idgrptbl;
		
     end;
		
		 * Om medlemmen är en grupp eller en superanvändare ska den med i admingruppen;
		 if org_group = 1 and (index(member, "-SAS") or put(member, $superanv.) = "J") then do;
     grpkeyid=name;
     memkeyid=member; 
		 * om medlemmen är en grupp, tar bort '-SAS' från namnet gör sedan om den till en admingrupp genom att sätta suffixet "-W";
       if index(member, "-SAS") then do;
			   tmp_member = substr(compress(reverse(member)), 5);
				 member = compress(reverse(tmp_member));
				 drop tmp_member;
         memkeyid=compress(member !!"-W");
       end; 
			 * memkeyid=saMAccountName;

     output &idgrpmemstbl;	
		 end;

		 drop org_group;
		 * Slut: Anpassning LUL;
run;


/* Get user details using the members extracted above */
data adExt.ldapusers                                                               
     (keep= displayName streetAddress cn company mail employeeID facsimileTelephoneNumber 
            distinguishedName l mobile otherTelephone physicalDeliveryOfficeName postalCode name 
            sAMAccountName st telephoneNumber co title whenChanged whenCreated);

	length entryname $200 attrName $100 value $600 filter $200
	    displayName $256 streetAddress $100 cn $40 company $50 mail $50 
	    employeeID $30 facsimileTelephoneNumber $50 distinguishedName $200
	    l $50 mobile $50 otherTelephone $50 physicalDeliveryOfficeName $50
	    postalCode $20 name $60 sAMAccountName $20 st $20 telephoneNumber $50
	    co $50 /*title $50*/ whenChanged $30 whenCreated $30;

	set &dwlib..fimobjects (where=(username not is missing)keep= firstname middlename lastname title fullpath email username enddate);
	if middlename ne "" then DisplayName= trim(FirstName)||' '||trim(MiddleName)||' '||trim(LastName);
	else if middlename eq "" then DisplayName= trim(FirstName)||' '||trim(LastName);
  * Ta bara med de med gällande anställning;
	date = datepart(enddate);
	if (date = .) or (date ge today()); 
	sAMAccountName = UserName;
	mail=email;
	name =UserName;
	company=fullpath;
 	employeeID=UserName;
run;

/******************************************************************************************/
/* If the dataset is empty, then something went wrong with the extract.  Cancel execution */
/* with the SYSINFO macro variable set to 2.                                              */
/******************************************************************************************/
proc sql noprint;
   select count(*) into :ldapusers_nobs from adExt.ldapusers;
quit;
   
data _null_;
   if &ldapusers_nobs eq 0 then do;
      put "ERROR: User extraction failed.  The dataset adExt.ldapusers contains no observations.";
      put "ERROR: Cancelling execution of submitted statements.";
      abort cancel 2;
   end;
run;

/**********************************************************************************/
/* If we were using the anything other than the DN as the keyid for persons, then */
/* we need to re-code the person group memberkeys from DN to the proper keyid     */
/* so that they match.                                                            */
/**********************************************************************************/
%transmemkeyid;

/******************************************************************************************/
/* The following datastep creates the normalized tables for person, location,             */
/* phone, email, and login from the adExt.ldapusers extracted above.            */
/******************************************************************************************/


data &persontbla                      /* Macros to define Normalized Tables from %mduimpc */
     &locationtbla
     &phonetbla
     &emailtbla
     &logintbla 
      ;
     %definepersoncols;        /* Macros to define Normalized Table Columns from %mduimpc */
     %definelocationcols;
     %definephonecols;
     %defineemailcols;
     %definelogincols; 

     set adExt.ldapusers;
                                            
     keyid = &keyidvar;
  
     description=company;  
     output &persontbl;
                             
     if email NE "" then do;
        emailAddr = email;
        emailType = "Office";
        output &emailtbl;
     end; 
                     
     if UserName NE "" then do; 
      
        /* setup login values */ 
        /* we need to prefix the login user id with the domain id */
       
        if "&WindowsDomain" = "" then
           userid = UserName ;
        else
           userid = "&WindowsDomain\" || UserName ;  
      
        password ="";
        authdomkeyid = 'domkey' || compress(upcase("&MetadataAuthDomain"));

        output &logintbl;
     end;                                                                                        
run;                                                          


/************************************************************************/
/* The following datastep creates the normalized table for the          */ 
/* AuthenticationDomain specified in the &MetadataAuthDomain near the   */
/* beginning of this SAS code.  This value is also used to create the   */
/* foreign key variable "authdomkeyid" for the logins table in the next */ 
/* datastep, forming the relation between the authdomtbl and logintbl.  */
/************************************************************************/

data &authdomtbl;
     %defineauthdomcols;  /* Macros to define Table authdomain from %mduimpc */
     authDomName="&MetadataAuthDomain";
     keyid='domkey' || compress(upcase("&MetadataAuthDomain"));
	 output;
	 authDomName="web";
     keyid='domkeyWEB';
		 output;
run;
 

                                                     
